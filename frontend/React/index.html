<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React | YUHUI&#39;S Dev-Notes</title>
    <meta name="description" content="日常开发技术总结笔记，技术答疑！">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    
    <link rel="preload" href="/Developer-notes/assets/css/0.styles.676ffd4a.css" as="style"><link rel="preload" href="/Developer-notes/assets/js/app.9ca3cd04.js" as="script"><link rel="preload" href="/Developer-notes/assets/js/29.67919cbd.js" as="script"><link rel="prefetch" href="/Developer-notes/assets/js/10.01d11ca3.js"><link rel="prefetch" href="/Developer-notes/assets/js/11.2b8dd230.js"><link rel="prefetch" href="/Developer-notes/assets/js/12.6298d3e3.js"><link rel="prefetch" href="/Developer-notes/assets/js/13.9c077031.js"><link rel="prefetch" href="/Developer-notes/assets/js/14.058a2157.js"><link rel="prefetch" href="/Developer-notes/assets/js/15.9900ee6e.js"><link rel="prefetch" href="/Developer-notes/assets/js/16.4587a3a3.js"><link rel="prefetch" href="/Developer-notes/assets/js/17.5b77fd45.js"><link rel="prefetch" href="/Developer-notes/assets/js/18.40e15717.js"><link rel="prefetch" href="/Developer-notes/assets/js/19.4b29d712.js"><link rel="prefetch" href="/Developer-notes/assets/js/2.37d8e32e.js"><link rel="prefetch" href="/Developer-notes/assets/js/20.2249a9a1.js"><link rel="prefetch" href="/Developer-notes/assets/js/21.a95616b9.js"><link rel="prefetch" href="/Developer-notes/assets/js/22.b49c0aef.js"><link rel="prefetch" href="/Developer-notes/assets/js/23.6903dc94.js"><link rel="prefetch" href="/Developer-notes/assets/js/24.cbd60039.js"><link rel="prefetch" href="/Developer-notes/assets/js/25.71394ec6.js"><link rel="prefetch" href="/Developer-notes/assets/js/26.1490817c.js"><link rel="prefetch" href="/Developer-notes/assets/js/27.c721559e.js"><link rel="prefetch" href="/Developer-notes/assets/js/28.22713b83.js"><link rel="prefetch" href="/Developer-notes/assets/js/3.ef190807.js"><link rel="prefetch" href="/Developer-notes/assets/js/30.6c81aa37.js"><link rel="prefetch" href="/Developer-notes/assets/js/31.37cb33b9.js"><link rel="prefetch" href="/Developer-notes/assets/js/32.d7b10612.js"><link rel="prefetch" href="/Developer-notes/assets/js/33.93ce0faf.js"><link rel="prefetch" href="/Developer-notes/assets/js/34.80528f5f.js"><link rel="prefetch" href="/Developer-notes/assets/js/35.28454fb9.js"><link rel="prefetch" href="/Developer-notes/assets/js/36.17d2471a.js"><link rel="prefetch" href="/Developer-notes/assets/js/37.ec5cb400.js"><link rel="prefetch" href="/Developer-notes/assets/js/38.da0bcd9f.js"><link rel="prefetch" href="/Developer-notes/assets/js/39.00de1477.js"><link rel="prefetch" href="/Developer-notes/assets/js/4.26a43768.js"><link rel="prefetch" href="/Developer-notes/assets/js/40.2a65a882.js"><link rel="prefetch" href="/Developer-notes/assets/js/41.c422d9e5.js"><link rel="prefetch" href="/Developer-notes/assets/js/42.6aa8eaed.js"><link rel="prefetch" href="/Developer-notes/assets/js/43.76eca484.js"><link rel="prefetch" href="/Developer-notes/assets/js/44.bb64d422.js"><link rel="prefetch" href="/Developer-notes/assets/js/45.f5254139.js"><link rel="prefetch" href="/Developer-notes/assets/js/5.710896d2.js"><link rel="prefetch" href="/Developer-notes/assets/js/6.dc32a1d5.js"><link rel="prefetch" href="/Developer-notes/assets/js/7.6592e037.js"><link rel="prefetch" href="/Developer-notes/assets/js/8.753b4984.js"><link rel="prefetch" href="/Developer-notes/assets/js/9.08f8ef81.js">
    <link rel="stylesheet" href="/Developer-notes/assets/css/0.styles.676ffd4a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Developer-notes/" class="home-link router-link-active"><!----> <span class="site-name">YUHUI'S Dev-Notes</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Developer-notes/" class="nav-link">Home</a></div><div class="nav-item"><a href="/Developer-notes/about/" class="nav-link">About</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Google
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/Developer-notes/frontend/index.html" class="nav-link">前端</a></div><div class="nav-item"><a href="/Developer-notes/backend/index.html" class="nav-link">后端</a></div><div class="nav-item"><a href="/Developer-notes/embedded/index.html" class="nav-link">嵌入式</a></div><div class="nav-item"><a href="/Developer-notes/computerbasic/index.html" class="nav-link">计算机基础</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Developer-notes/" class="nav-link">Home</a></div><div class="nav-item"><a href="/Developer-notes/about/" class="nav-link">About</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Google
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/Developer-notes/frontend/index.html" class="nav-link">前端</a></div><div class="nav-item"><a href="/Developer-notes/backend/index.html" class="nav-link">后端</a></div><div class="nav-item"><a href="/Developer-notes/embedded/index.html" class="nav-link">嵌入式</a></div><div class="nav-item"><a href="/Developer-notes/computerbasic/index.html" class="nav-link">计算机基础</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Developer-notes/about/" class="sidebar-link">本站简介</a></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>前端</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/Developer-notes/frontend/" class="sidebar-link">前端基础</a></li><li><a href="/Developer-notes/frontend/React/" class="active sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Developer-notes/frontend/React/#组件模式" class="sidebar-link">组件模式</a></li><li class="sidebar-sub-header"><a href="/Developer-notes/frontend/React/#react-redux" class="sidebar-link">React Redux</a></li><li class="sidebar-sub-header"><a href="/Developer-notes/frontend/React/#immutable" class="sidebar-link">immutable</a></li><li class="sidebar-sub-header"><a href="/Developer-notes/frontend/React/#集成第三方-js-库的技术要点" class="sidebar-link">集成第三方 JS 库的技术要点</a></li></ul></li><li><a href="/Developer-notes/frontend/React/ReactNative.html" class="sidebar-link">React Native</a></li><li><a href="/Developer-notes/frontend/Vue/" class="sidebar-link">Vue 相关</a></li><li><a href="/Developer-notes/frontend/Angular/" class="sidebar-link">Angular</a></li><li><a href="/Developer-notes/frontend/module-bundler/" class="sidebar-link">打包工具</a></li><li><a href="/Developer-notes/frontend/MiniProgram/" class="sidebar-link">小程序</a></li><li><a href="/Developer-notes/frontend/nodejs/" class="sidebar-link">node.js</a></li><li><a href="/Developer-notes/frontend/Performance/" class="sidebar-link">Performance</a></li><li><a href="/Developer-notes/frontend/mobileweb/" class="sidebar-link">Mobile Web</a></li><li><a href="/Developer-notes/frontend/Network/" class="sidebar-link">常用网络</a></li><li><a href="/Developer-notes/frontend/WebGL/Canvas.html" class="sidebar-link">Canvas</a></li><li><a href="/Developer-notes/frontend/WebGL/" class="sidebar-link">WebGL</a></li><li><a href="/Developer-notes/frontend/WebGL/GLSL.html" class="sidebar-link">GLSL 手册</a></li><li><a href="/Developer-notes/frontend/TypeScript/" class="sidebar-link">TypeScript</a></li><li><a href="/Developer-notes/frontend/Regexp/" class="sidebar-link">正则</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>后端</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>嵌入式</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>基础</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="react">React</h1> <h3 id="_1-react-的-key-的作用以及实现原理，并设定一个具体情境进行分析">1.react 的 key 的作用以及实现原理，并设定一个具体情境进行分析</h3> <p>React 可以具有一个特殊的属性 <code>key</code>，这个属性不是给用户自己用的，而是给 React 自己用的。</p> <p>如果动态创建一个 React 元素，而且 React 元素内包含数量或顺序不确定的子元素时，就需要提供 <code>key</code> 这个特殊的属性。</p> <p>例如有这样的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">userList</span> <span class="token operator">=</span> <span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>h3<span class="token operator">&gt;</span>用户列表<span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span>props<span class="token punctuation">.</span>users<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">u</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>u<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token punctuation">:</span><span class="token punctuation">{</span>u<span class="token punctuation">.</span>name<span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment">// 没有提供 key</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_2-react-里什么时候用-context？">2.React 里什么时候用 Context？</h3> <h3 id="_3-reader-props-是什么？-什么时候用？">3.reader props 是什么？ 什么时候用？</h3> <h3 id="_4-路由如何做权限校验？">4.路由如何做权限校验？</h3> <h3 id="_5-如何正确理解-react-的生命周期？">5.如何正确理解 React 的生命周期？</h3> <p><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener noreferrer">可以参考这个图<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <img src="https://raw.githubusercontent.com/AlvinMi/2019-Pic/master/2019/20190504011403.png"> <p>每个 React 组件都会经历挂载(Mounting)、更新(Updating)、和卸载(Unmounting)的过程。</p> <p>React 每个过程都提供一些钩子函数，让我们可以自定义一些事情。</p> <p><strong>constructor</strong></p> <ul><li>1.用于初始化内部状态</li> <li>2.唯一可以直接修改 State 的地方</li></ul> <p><strong>getDerivedStateFromProps</strong></p> <ul><li>1.当 State 需要从 props 初始化时使用</li> <li>2.尽量不要使用：维护两者状态一致性会增加复杂度(可以通过计算获得，不用单独存储，不然就得维护两者的一致性)</li> <li>3.每次 render 都会调用</li> <li>4.典型场景：表单控件获取默认值</li></ul> <p><strong>componentDidMount</strong></p> <ul><li>1.UI 渲染完成后调用</li> <li>2.只执行一次</li> <li>3.典型场景：获取外部资源</li></ul> <p><strong>componentWillUnmount</strong></p> <ul><li>1.组件移除时被调用</li> <li>2.典型场景: 资源释放</li></ul> <p><strong>getSnapshotBeforeUpdate</strong></p> <ul><li>1.在页面 render 之前调用，State 已更新</li> <li>2.典型场景：获取 render 之前的 DOM 状态</li></ul> <p><strong>componentDidUpdate</strong></p> <ul><li>1.每次 UI 更新时被调用</li> <li>2.典型场景：页面需要根据 props 变化重新获取数据</li></ul> <p><strong>△shouldComponentUpdate</strong></p> <ul><li>1.决定 VirtualDOM 是否要重绘</li> <li>2.一般可以由 <strong>PureCommont</strong> 自动实现</li> <li>3.典型场景：性能优化</li></ul> <h3 id="_6-pure-component-和-shouldcomponentupdate-相关概念的考察？">6.pure-component 和 shouldComponentUpdate 相关概念的考察？</h3> <p><strong>shouldComponentUpdate</strong></p> <ul><li>1.决定 Virtual DOM 是否需要重绘</li> <li>2.一般可以由 <code>PureComponent</code> 自动实现</li> <li>3.典型场景：性能优化</li></ul> <p><strong>pure-component</strong></p> <p>可以判断当前的 State 和之前的 State，当前的 props 和之前的 props 是否有变化，如果没有变化，它会自动阻止 React 去重新更新。</p> <h3 id="_7-组件生命周期？">7.组件生命周期？</h3> <h3 id="_8-react-在什么时候比较适合做-ssr？">8.React 在什么时候比较适合做 SSR？</h3> <p>React 在有 Node 做中间层的时候比较适合做 SSR，另一方面需要看业务，如果网站需要 SEO，那么就需要做 SSR。后台系统、WebAPP 倒不需要 SSR。</p> <h3 id="_9-react-的-diff-算法基本原理与源码解释">9.react 的 diff 算法基本原理与源码解释?</h3> <h3 id="_10-如何细粒度地控制-react-组件更新">10.如何细粒度地控制 react 组件更新?</h3> <h3 id="_11-js-的基本函数式使用，比如-reduce、curry">11.JS 的基本函数式使用，比如 reduce、curry?</h3> <h3 id="_12-对-redux-和-mobx-的「设计理念」理解？">12.对 Redux 和 Mobx 的「设计理念」理解？</h3> <h3 id="_13-virtual-dom-的基本原理与简单的源码解释？">13.virtual-dom 的基本原理与简单的源码解释？</h3> <h3 id="_14-你认为-react-有什么应该-deprecate-的特性">14.你认为 React 有什么应该 deprecate 的特性?</h3> <h3 id="_15-聊一聊怎么改良一个-react-的数据流-lib-吗-哈哈哈，在知乎上看到这题。-ಥ-ಥ">15.聊一聊怎么改良一个 React 的数据流 lib 吗? (哈哈哈，在知乎上看到这题。(ಥ_ಥ))</h3> <h3 id="_16-react-component-purecomponent-的区别？">16.React Component &amp; PureComponent 的区别？</h3> <h3 id="_17-props-state">17.props &amp; state?</h3> <h3 id="_18-什么时候可以-直接修改-state-的值？">18.什么时候可以[直接修改] state 的值？</h3> <p>在 Constructor 里面修改，一般来说要更新 state 都会使用 <code>setState</code> 方法， Constructor 里面什么事情都还没有做，可以使用 <code>this.state.xxx = &quot;xxx&quot;</code> 这样的形式修改，这也是唯一可以直接修改 State 的方法。</p> <h3 id="_19">19.</h3> <h3 id="约定">约定</h3> <p>创建组件的单一职责原则：</p> <ul><li><p>1.每个组件只做一件事</p></li> <li><p>2.如果组件变得复杂，那么应该拆分成小组件</p></li> <li><p>React 认为小写的 tag 是原生 DOM 节点，如 <code>div</code>;</p></li> <li><p>大写字母开头为自定义组件；</p></li> <li><p>JSX 标记可以直接使用属性语法，例如 <code>&lt;menu.Item/&gt;</code></p></li></ul> <h2 id="组件模式">组件模式</h2> <p>有状态组件-无状态组件、容器组件-展示组件、高阶组件-渲染回调(函数作为子组件)</p> <h2 id="react-redux">React Redux</h2> <p>Redux 并不是必须的，只是良好的解决了状态管理，减少维护时候的 bug。</p> <img src="https://raw.githubusercontent.com/AlvinMi/2019-Pic/master/2019/20190504202756.png"> <blockquote><p>题图来自 https://css-tricks.com/learning-react-redux/</p></blockquote> <p>Redux 让组件通信变得更加容易。</p> <p>Redux 特性：</p> <ul><li>1.Single Source of Truth，所有的状态都放在唯一的 store 中</li> <li>2.可预测性： State + action = new State</li> <li>3.纯函数更新 Stroe</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">todos</span><span class="token punctuation">(</span><span class="token parameter">stete <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span><span class="token punctuation">:</span> <span class="token string">'ADD_TODO'</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span> text<span class="token punctuation">:</span> action<span class="token punctuation">.</span>text<span class="token punctuation">,</span> completed<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span><span class="token punctuation">:</span> <span class="token string">'TOGGLE_TODO'</span><span class="token punctuation">:</span>
      <span class="token comment">// state.map 生成了一个新的对象</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">(</span>
        <span class="token punctuation">(</span><span class="token parameter">todo<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
          action<span class="token punctuation">.</span>index <span class="token operator">===</span> index
            <span class="token operator">?</span> <span class="token punctuation">{</span> text<span class="token punctuation">:</span> todo<span class="token punctuation">.</span>text<span class="token punctuation">,</span> completed<span class="token punctuation">:</span> <span class="token operator">!</span>todo<span class="token punctuation">.</span>completed <span class="token punctuation">}</span>
            <span class="token punctuation">:</span> todo
      <span class="token punctuation">)</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> state
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>React &amp; Redux 是如何配置的？ react-redux 提供了 connect 和 Provider，一个将组件与 redux 关联起来，一个将 store 传递给组件。组件通过 dispatch 发出的 action，store 根据 action 的 type 属性调用对应的 reducer 并传入 setState 更新组件，组件的 props 也就跟随变化了。</p> <p>Redux 主要由三部分组成： store、action reducer。</p> <p><strong>store</strong> 是一个对象，主要有 4 个方法：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 产生一个 store 只需要 createStore</span>
<span class="token keyword">let</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>todoApp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>1.getState()</p> <p>获取 store 中的 state, 用 action 触发 reducer 改变 state 时，需要再拿到新的 state 里的数据，毕竟数据才是我们想要的。</p> <p>getState 主要在两个地方需要用到：</p> <ul><li>一是在 dispatch 拿到 action 后 store 需要用它来获取 state 里的数据，并把这个数据传给 reducer，这个过程是自动执行的</li> <li>二是在我们利用 subscribe 监听到 state 发生变化后调用它来获取新的 state 数据，如果做到这一步，说明我们已经成功了</li></ul> <p>2.dispatch(action)</p> <p>例如 UI 上当用户点击一个 button 的时候就产生了一个 action，store 就把它 dispatch 出去，dispatch 给 reducer。</p> <p>在 createStore 中可以用 middleware 中间件对 dispatch 进行改造，比如当 action 传入 dispatch 会立即触发 reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用 redux-thunk 对 dispatch 进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动 dispatch 一个 action 对象，这个过程是可控的，就实现了异步</p> <p>3.subscribe(listener)</p> <p>监听 store 的变化，在 store 调用 dispatch 时会注册一个 listener 监听 state 变化。</p> <p>4.replaceReducer(nextReducer)</p> <p>替换 reducer，改变 state 修改的逻辑。</p> <p><strong>action</strong>, 是一个对象，其中 type 属性是必须的，同时可以传入一些数据。</p> <p>action 可以使用 actionCreator 进行创造, dispatch 就是把 action 对象发送出去。</p> <p><strong>reducer</strong>, 是一个函数，接收两个参数。一个 state 和一个 action。</p> <p>根据 action 的 type 返回一个新的 state。</p> <p>根据业务逻辑可以分成多个 reducer, 然后通过 combineReducers 将它们合并， state 树中有很多对象，每个 state 对象对应一个 reducer， state 对象的名字可以在合并时定义。如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> reducer <span class="token operator">=</span> <span class="token function">combineReducers</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> doSomethingWithA<span class="token punctuation">,</span>
  b<span class="token punctuation">:</span> processB<span class="token punctuation">,</span>
  c<span class="token punctuation">:</span> c
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>combineReducers</strong></p> <p>最终是一个封装过的函数，其实也是一个 reducer，接收整个 state 和 一个 action，然后将整个 state 拆分发送给对应的 reducer 进行处理，所有的 reducer 会收到相同的 action，不过它们会根据 action 的 type 进行判断，有这个 type 就进行处理然后返回新的 state，没有就返回默认值，然后这些分散的 state 又会被整合在一起返回一个新的 state 树。</p> <blockquote><p>React 的 state 和 redux 的 state 两者完全是没有关系的，只是名字一样。</p></blockquote> <p><strong>bindActionCreators</strong></p> <p>也是一个工具函数，帮助我们方便的去使用 action.</p> <p>分析一下整体的流程如下：</p> <blockquote><p>先调用 store.dispatch 将 action 作为参数传入，同时用 getState 获取当前的状态树 state 并注册 subscribe 的 listener 监听 state 变化，再调用 combineReducers 并将获取的 state 和 action 传入。 combineReducers 会将传入的 state 和 action 传给所有 reducer，并根据 action 的 type 返回新的 state，触发 state 树的更新，我们调用 subscribe 监听到 state 发生变化后用 getState 获取新的 state 数据。</p></blockquote> <h3 id="react-redux-2">React-Redux</h3> <p>如果只使用 redux，流程是这样的：</p> <blockquote><p>component --&gt; dispatch(action) --&gt; reducer --&gt; subscribe --&gt; getState --&gt; component</p></blockquote> <p>用了 <code>react-redux</code> 之后流程就是这样的：</p> <blockquote><p>component --&gt; actionCreator(data) --&gt; reducer --&gt; component</p></blockquote> <p>这样 store 的三大功能：<code>dispatch</code>，<code>subscribe</code>，<code>getState</code> 都不需要手动来写了。<code>react-redux</code> 帮我们做了这些，同时它提供了两个好基友 Provider 和 connect 。</p> <p><strong>Provider</strong></p> <p>Provider 是一个组件，它接受 store 作为 props，然后通过 context 往下传，这样 react 中任何组件都可以通过 context 获取 store。</p> <p><strong>connect</strong></p> <p>connect(mapStateToProps, mapDispatchToProps, mergeProps, options) 是一个函数，它接受四个参数并且再返回一个函数, <code>wrapWithConnect</code>，<code>wrapWithConnect</code> 接受一个组件作为参数 <code>wrapWithConnect(component)</code>，它内部定义一个新组件 Connect (容器组件) 并将传入的组件 (ui 组件) 作为 Connect 的子组件然后 return 出去。</p> <p>完整的写法：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 高阶函数的形式</span>
<span class="token function">connect</span> <span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">,</span> mapDispatchToProps<span class="token punctuation">,</span> mergeProps<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>mapStateToProps(state, [ownProps]):</p> <p>mapDispatchToProps(dispatch, [ownProps]):</p> <p>mergeProps(stateProps, dispatchProps, ownProps):</p> <p>options:</p> <h3 id="_1-react-redux-怎么处理多线程文档，管理多个请求并发的问题？">1.React Redux 怎么处理多线程文档，管理多个请求并发的问题？</h3> <p>JS 是单线程的，但是可以做到请求并发，如果想要多个请求都返回时才处理，可以使用 Promise.all</p> <h4 id="_1-1-如何看待用-worker-的方式启动新线程-var-worker-new-worker-js-file-path-？">1.1.如何看待用 worker 的方式启动新线程(var worker = new Worker(js file path))？</h4> <p>在有密集计算，又不希望卡主线程的情况下，原来只能用 <code>setTimeout</code> 分片，现在可以用 worker 了，有实际使用场景下非常棒。</p> <h3 id="_2-数据状态管理：-dry-don-t-repeat-yourself-原则">2.数据状态管理： DRY(Don't Repeat Yourself) 原则</h3> <ul><li>1.能计算得到的状态就不要单独存储</li> <li>2.组件尽量无状态，所需数据通过 props 获取</li></ul> <h2 id="immutable">immutable</h2> <p><strong>缺点</strong></p> <ul><li>1.API 风格易与原生对象搞混淆</li> <li>2.用第三方组件的时候, 需要使用 <code>toJS()</code>、<code>fromJS()</code> 方法，在原生和 immutable 对象之间互相转换</li></ul> <p><strong>优势</strong></p> <ul><li>1.比较引用即深度比较，极大的方便了在 SCU(shouldComponentUpdate) 中进行性能优化</li> <li>2.防止不小心直接改变一些按引用传递的数据结构造成的 bug</li> <li>3.节省内存</li></ul> <h2 id="集成第三方-js-库的技术要点">集成第三方 JS 库的技术要点</h2> <ul><li>1.使用 ref 获取原生 DOM 节点引用？</li> <li>2.手动将组件状态更新到 DOM 节点？</li> <li>3.组件销毁时移除原生节点 DOM 事件？</li></ul></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Developer-notes/frontend/" class="prev router-link-active">
          前端基础
        </a></span> <span class="next"><a href="/Developer-notes/frontend/React/ReactNative.html">
          React Native
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/Developer-notes/assets/js/app.9ca3cd04.js" defer></script><script src="/Developer-notes/assets/js/29.67919cbd.js" defer></script>
  </body>
</html>
